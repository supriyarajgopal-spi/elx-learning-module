<?php

/**
 * @file
 * Migration scripts for ELX content.
 */

/**
 * Implements hook_install().
 */
function elx_content_tool_install() {
  // Mark as needing updates.
  drupal_set_installed_schema_version('elx_content_tool', SCHEMA_INSTALLED);
}

/**
 * Switch from field translations to translation nodes.
 */
function elx_content_tool_update_7100() {
  foreach (node_type_get_types() as $node_type) {
    if (variable_get("language_content_type_$node_type->type", 0) == ENTITY_TRANSLATION_ENABLED) {
      variable_set("language_content_type_$node_type->type", TRANSLATION_ENABLED);
    }
  }
}

/**
 * Create a translation node for each field translation.
 */
function elx_content_tool_update_7101(&$sandbox) {
  if (module_exists('entity_translation')) {
    if (!isset($sandbox['progress'])) {
      $sandbox['progress'] = 0;
      $query = db_select('node', 'n');
      $query->join('entity_translation', 't', 'n.nid = t.entity_id');
      $sandbox['max'] = $query
        ->condition('t.entity_type', 'node')
        ->condition('t.source', '', '<>')
        ->countQuery()
        ->execute()
        ->fetchField();
      // Load node reference fields. They need to be updated to reference the
      // translation nodes.
      $sandbox['node_references'] = array();
      foreach (field_read_fields(array('type' => 'entityreference')) as $field_name => $field) {
        if ($field['translatable'] && $field['settings']['target_type'] == 'node') {
          $sandbox['node_references'][$field_name] = $field;
        }
      }
    }
    $query = db_select('node', 'n');
    $query->join('entity_translation', 't', 'n.nid = t.entity_id');
    $result = $query
      ->fields('t')
      ->condition('t.entity_type', 'node')
      ->condition('t.source', '', '<>')
      ->range(0, 10)
      ->execute();
    foreach ($result as $translation) {
      // Load translation source node.
      $source_node = node_load($translation->entity_id);
      $author = user_load($translation->uid);
      $form_state = array(
        'values' => array(
          'op' => t('Save'),
        ),
      );
      form_load_include($form_state, 'pages.inc', 'node');
      // Check for existing translation nodes.
      $translations = translation_node_get_translations($source_node->nid);
      if (isset($translations[$translation->language])) {
        $node = $translations[$translation->language];
        $node->tnid = $source_node->nid;
      }
      else {
        // If there is no existing translation node, create an empty object.
        $node = new stdClass();
      }
      $node->log = t('Converted field translation to node translation.');
      $node->type = $source_node->type;
      $node->name = $author->name;
      $node->date = format_date($translation->created, 'custom', 'Y-m-d H:i:s O');
      $node->changed = $translation->changed;
      $node->status = $translation->status;
      $node->promote = $source_node->promote;
      $node->sticky = $source_node->sticky;
      $node->comment = $source_node->comment;
      $node->language = $translation->language;
      $node->translation_source = $source_node;
      $node->title = $source_node->title;
      if (module_exists('title') && title_field_replacement_enabled('node', $source_node->type, 'title')) {
        $title = title_entity_label($source_node, 'node', $translation->language);
        if (!empty($title)) {
          $node->title = $title;
        }
      }
      // In case required fields were not translated, copy values from source
      // fields.
      field_attach_prepare_translation('node', $node, $translation->language, $source_node, $source_node->language);
      // Copy values from the translated fields.
      field_attach_prepare_translation('node', $node, $translation->language, $source_node, $translation->language);
      // Messages generated by saving a translation node will be skipped
      // because the translation node should match the entity translation,
      // including data errors. Save previous messages before starting.
      $messages = drupal_get_messages();
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        // Ensure saved messages are restored even if there is an error.
        try {
          // Save translation node.
          drupal_form_submit($node->type . '_node_form', $form_state, $node);
          $errors = form_get_errors();
          if (!empty($errors)) {
            throw new DrupalUpdateException(implode("\n", $errors));
          }
          // Restore saved messages.
          $_SESSION['messages'] = $messages;
        }
        catch (Exception $e) {
          // Restore saved messages.
          $_SESSION['messages'] = $messages;
          throw $e;
        }
        // Check for successful translation node creation.
        if (isset($node->tnid) && $node->tnid == $source_node->nid) {
          // Make sure original translation status is saved.
          if (empty($node->translate) && !empty($translation->translate) || !empty($node->translate) && $node->translate != $translation->translate) {
            $node->translate = $translation->translate;
            translation_node_update($node);
          }
          // Update node references in this language to point to the translation
          // node.
          foreach ($sandbox['node_references'] as $field_name => $field) {
            $query = new EntityFieldQuery();
            $result = $query
              ->fieldCondition($field, 'target_id', $node->tnid)
              ->fieldLanguageCondition($field, $translation->language)
              ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT')
              ->execute();
            foreach ($result as $entity_type => $entities) {
              field_attach_load($entity_type, $entities, FIELD_LOAD_CURRENT, array('field_id' => $field['id']));
              foreach ($entities as $entity) {
                if (!empty($entity->{$field_name}[$translation->language])) {
                  foreach ($entity->{$field_name}[$translation->language] as &$item) {
                    if ($item['target_id'] == $node->tnid) {
                      $item['target_id'] = $node->nid;
                    }
                  }
                }
                field_attach_update($entity_type, $entity);
              }
              entity_get_controller($entity_type)->resetCache();
            }
          }
          // Remove entity translation.
          $handler = entity_translation_get_handler('node', $source_node);
          $source_node->original = $source_node;
          $handler->removeTranslation($translation->language);
          entity_translation_sync('node', $source_node);
          $handler->updateTranslations();
          $handler->saveTranslations();
          ++$sandbox['progress'];
        }
        else {
          throw new DrupalUpdateException('Failed to create translation node.');
        }
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
    }
    if (!empty($sandbox['max'])) {
      $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
    }
  }
}

/**
 * Add markets group to content types containing field_markets.
 */
function elx_content_tool_update_7102(&$sandbox) {
  _elx_content_tool_add_markets_field($sandbox, 'field_markets');
}

/**
 * Add markets group to content types containing field_market_name.
 */
function elx_content_tool_update_7103(&$sandbox) {
  _elx_content_tool_add_markets_field($sandbox, 'field_market_name');
}

/**
 * Add markets field to content types.
 */
function _elx_content_tool_add_markets_field(&$sandbox, $field_name) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['markets'] = field_info_field('markets');
    $sandbox['field_markets'] = field_info_field($field_name);
    // Users already have a groups field.
    if (isset($sandbox['field_markets']['bundles']['user'])) {
      unset($sandbox['field_markets']['bundles']['user']);
    }
    // Get the total number of old markets fields.
    $sandbox['max'] = array_sum(array_map('count', $sandbox['field_markets']['bundles']));
    // Subtract markets groups that match old markets fields.
    foreach ($sandbox['markets']['bundles'] as $entity_type => $bundles) {
      if (isset($sandbox['field_markets']['bundles'][$entity_type])) {
        $sandbox['max'] -= count(array_intersect($bundles, $sandbox['field_markets']['bundles'][$entity_type]));
      }
    }
  }
  $count = 0;
  foreach ($sandbox['field_markets']['bundles'] as $entity_type => $bundles) {
    // Add the OG markets field to bundles that do not have it.
    foreach (array_diff($bundles, isset($sandbox['markets']['bundles'][$entity_type]) ? $sandbox['markets']['bundles'][$entity_type] : array()) as $bundle) {
      $og_field = og_fields_info('og_group_ref');
      $og_field['instance']['label'] = 'Markets';
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        og_create_field('markets', $entity_type, $bundle, $og_field);
        ++$sandbox['progress'];
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
      if (++$count == 10) {
        break 2;
      }
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Add groups content access field to content types containing markets.
 */
function elx_content_tool_update_7104(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['access'] = field_info_field(OG_CONTENT_ACCESS_FIELD);
    $sandbox['markets'] = field_info_field('markets');
    // Users are not content.
    if (isset($sandbox['markets']['bundles']['user'])) {
      unset($sandbox['markets']['bundles']['user']);
    }
    // Get total number of old markets fields.
    $sandbox['max'] = array_sum(array_map('count', $sandbox['markets']['bundles']));
    // Subtract OG markets fields that match old markets fields.
    foreach ($sandbox['access']['bundles'] as $entity_type => $bundles) {
      if (isset($sandbox['markets']['bundles'][$entity_type])) {
        $sandbox['max'] -= count(array_intersect($bundles, $sandbox['markets']['bundles'][$entity_type]));
      }
    }
  }
  $count = 0;
  foreach ($sandbox['markets']['bundles'] as $entity_type => $bundles) {
    // Add groups access field to bundles that do not have it.
    foreach (array_diff($bundles, isset($sandbox['access']['bundles'][$entity_type]) ? $sandbox['access']['bundles'][$entity_type] : array()) as $bundle) {
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        og_create_field(OG_CONTENT_ACCESS_FIELD, $entity_type, $bundle);
        ++$sandbox['progress'];
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
      if (++$count == 10) {
        break 2;
      }
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Set content visibility.
 */
function elx_content_tool_update_7105(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['field'] = field_info_field(OG_CONTENT_ACCESS_FIELD);
    $sandbox['table'] = _field_sql_storage_tablename($sandbox['field']);
    // Get the total number of entities that are missing their content
    // visibility setting.
    $sandbox['max'] = 0;
    foreach ($sandbox['field']['bundles'] as $entity_type => $bundles) {
      $info = entity_get_info($entity_type);
      $query = db_select($info['base table'], 'b');
      $query->leftJoin($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id AND f.entity_type = :entity_type', array(
        ':entity_type' => $entity_type,
      ));
      $sandbox['max'] += $query
        ->condition(db_or()
          ->condition('f.deleted', 1)
          ->isNull('f.entity_id')
        )
        ->countQuery()
        ->execute()
        ->fetchField();
    }
  }
  foreach ($sandbox['field']['bundles'] as $entity_type => $bundles) {
    // Use a transaction so we can clean up errors.
    $transaction = db_transaction();
    try {
      $info = entity_get_info($entity_type);
      // Find all entities that are missing their content visibility setting.
      $query = db_select($info['base table'], 'b');
      $query->leftJoin($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id AND f.entity_type = :entity_type', array(
        ':entity_type' => $entity_type,
      ));
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => $entity_type));
      $query->addField('b', $info['entity keys']['id'], 'entity_id');
      $query->addField('b', isset($info['entity keys']['revision']) ? $info['entity keys']['revision'] : $info['entity keys']['id'], 'revision_id');
      $query->addField('b', isset($info['entity keys']['bundle']) ? $info['entity keys']['bundle'] : $entity_type, 'bundle');
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':value', _field_sql_storage_columnname(OG_CONTENT_ACCESS_FIELD, 'value'), array(':value' => OG_CONTENT_ACCESS_DEFAULT));
      $query
        ->condition(db_or()
          ->condition('f.deleted', 1)
          ->isNull('f.entity_id')
        );
      // Save number to add to processed count.
      $count = $query->countQuery()->execute()->fetchField();
      // Save content visibility.
      db_insert($sandbox['table'])
        ->from($query)
        ->execute();
      // Add number to processed count.
      $sandbox['progress'] += $count;
    }
    catch (Exception $e) {
      $transaction->rollback();
      throw $e;
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Create table to map old market options to new market groups.
 */
function elx_content_tool_update_7106() {
  // Use a transaction so we can clean up errors.
  $transaction = db_transaction();
  try {
    db_create_table('elx_content_tool_markets_map', array(
      'description' => 'Temporary table to map market options to market groups.',
      'fields' => array(
        'market' => array(
          'description' => 'Old markets value.',
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
        ),
        'nid' => array(
          'description' => 'Market group {node}.nid.',
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'default' => 0,
        ),
      ),
      'primary key' => array('market'),
    ));
    // Map old market options to new market groups.
    $query = db_insert('elx_content_tool_markets_map')
      ->fields(array('market', 'nid'));
    $market_options = array();
    foreach (array('field_markets', 'field_market_name') as $field_name) {
      $field_markets = field_info_field($field_name);
      if (isset($field_markets['settings']['allowed_values'])) {
        $market_options += $field_markets['settings']['allowed_values'];
      }
    }
    foreach ($market_options as &$name) {
      if ($name = 'Travel Retail Middle Pacific') {
        $name = 'TR Mid-Pac';
      }
      elseif (strpos($name, 'Travel Retail ') === 0) {
        $name = substr_replace($name, 'TR ', 0, 14);
      }
    }
    // Handle market typos.
    $market_options['Colombia-Ecuador-Central America '] = 'Colombia - Ecuador - Central America';
    $market_options['Eau Claire'] = 'Eau Claire';
    $market_options['en'] = 'United States';
    $market_options['English'] = 'United States';
    $market_options['enpp'] = 'TR Mid-Pac';
    $market_options['Ireland'] = 'Ireland';
    $market_options['ko'] = 'Korea';
    $market_options['KRn'] = 'Korea';
    $market_options['NA'] = 'TR Americas - North America';
    $market_options['NOAM'] = 'TR Americas - North America';
    $market_options['Southern Cone-Chile-Peru-Argentina'] = 'Southern Cone - Chile - Peru - Argentina';
    $market_options['TR MY'] = 'TR Malaysia';
    $market_options['TR SG'] = 'TR Singapore';
    $market_options['TR TH'] = 'TR Thailand';
    $market_options['Travel Retail CN'] = 'TR China';
    $market_options['Travel Retail HK-Macau-TW'] = 'TR Hong Kong-Macau-Taiwan';
    $market_options['Travel Retail JP'] = 'TR Japan';
    $market_options['Travel Retail KR'] = 'TR Korea';
    $market_options['TRRAM-CC'] = 'TR Americas - Caribbean - Cancun';
    $market_options['U.K.'] = 'U.K.';
    $market_options['unisted states'] = 'United States';
    $market_options['ZAe'] = 'South Africa';
    $market_groups = db_select('node', 'n')
      ->fields('n', array('title', 'nid'))
      ->condition('n.type', 'market')
      ->execute()
      ->fetchAllKeyed();
    foreach ($market_options as $option => $name) {
      if (isset($market_groups[$name])) {
        $query->values(array(
          'market' => $option,
          'nid' => $market_groups[$name],
        ));
      }
    }
    $query->execute();
  }
  catch (Exception $e) {
    $transaction->rollback();
    throw $e;
  }
}

/**
 * Switch old field_markets values to new markets groups.
 */
function elx_content_tool_update_7107(&$sandbox) {
  _elx_content_tool_market_switch($sandbox, 'field_markets');
}

/**
 * Switch old field_market_name values to new markets groups.
 */
function elx_content_tool_update_7108(&$sandbox) {
  _elx_content_tool_market_switch($sandbox, 'field_market_name');
}

/**
 * Switch old markets field values to new markets group.
 */
function _elx_content_tool_market_switch(&$sandbox, $field_name) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['markets'] = field_info_field('markets');
    $sandbox['field_markets'] = field_info_field($field_name);
    $sandbox['table'] = _field_sql_storage_tablename($sandbox['field_markets']);
    $sandbox['column'] = _field_sql_storage_columnname($field_name, 'value');
    $sandbox['max'] = 0;
    foreach ($sandbox['field_markets']['bundles'] as $entity_type => $bundles) {
      $info = entity_get_info($entity_type);
      // Get the total number of old market values that have not been switched
      // to the new markets group.
      $query = db_select($info['base table'], 'b');
      $query->join($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id AND f.entity_type = :entity_type', array(
        ':entity_type' => $entity_type,
      ));
      $query->join('elx_content_tool_markets_map', 's', "f.$sandbox[column] = s.market");
      $query->leftJoin('og_membership', 'g', 'b.' . $info['entity keys']['id'] . ' = g.etid AND g.entity_type = :entity_type', array(
        ':entity_type' => $entity_type,
      ));
      $sandbox['max'] += $query
        ->isNull('g.etid')
        ->countQuery()
        ->execute()
        ->fetchField();
    }
  }
  foreach ($sandbox['field_markets']['bundles'] as $entity_type => $bundles) {
    // Use a transaction so we can clean up errors.
    $transaction = db_transaction();
    try {
      $field_name = $entity_type == 'user' ? 'og_user_node' : 'markets';
      $info = entity_get_info($entity_type);
      // Find all entities that are missing market groups.
      $query = db_select($info['base table'], 'b');
      $query->join($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id AND f.entity_type = :entity_type', array(
        ':entity_type' => $entity_type,
      ));
      $query->join('elx_content_tool_markets_map', 's', "f.$sandbox[column] = s.market");
      $query->leftJoin('og_membership', 'g', 'b.' . $info['entity keys']['id'] . ' = g.etid AND g.entity_type = :entity_type', array(
        ':entity_type' => $entity_type,
      ));
      $query->addExpression(':type', 'type', array(':type' => $sandbox['markets']['settings']['handler_settings']['membership_type']));
      $query->addField('b', $info['entity keys']['id'], 'etid');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => $entity_type));
      $query->addField('s', 'nid', 'gid');
      $query->addExpression(':group_type', 'group_type', array(':group_type' => 'node'));
      $query->addExpression(':state', 'state', array(':state' => OG_STATE_ACTIVE));
      $query->addExpression(':created', 'created', array(':created' => REQUEST_TIME));
      $query->addExpression(':field_name', 'field_name', array(':field_name' => $field_name));
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->isNull('g.etid');
      // Save number to add to processed count.
      $count = $query->countQuery()->execute()->fetchField();
      // Set market groups.
      db_insert('og_membership')
        ->from($query)
        ->execute();
      // Add number to processed count.
      $sandbox['progress'] += $count;
    }
    catch (Exception $e) {
      $transaction->rollback();
      throw $e;
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Assign market administrators.
 */
function elx_content_tool_update_7109() {
  $role = user_role_load_by_name('EL Regional Market Admin');
  $rid = array_search(OG_ADMINISTRATOR_ROLE, og_roles('node', 'market'));
  $query = db_select('users', 'u');
  $query->join('users_roles', 'r', 'u.uid = r.uid');
  $query->join('og_membership', 'g', 'u.uid = g.etid AND g.entity_type = :entity_type', array(
    ':entity_type' => 'user',
  ));
  $query->join('node', 'n', 'g.gid = n.nid AND g.group_type = :group_type', array(
    ':group_type' => 'node',
  ));
  $query->leftJoin('og_users_roles', 'gr', 'u.uid = gr.uid AND gr.rid = :rid AND gr.group_type = :group_type AND g.gid = gr.gid', array(
    ':rid' => $rid,
    ':group_type' => 'node',
  ));
  $query->addField('u', 'uid');
  $query->addExpression(':rid', 'rid', array(':rid' => $rid));
  $query->addField('g', 'group_type');
  $query->addField('g', 'gid');
  $query
    ->condition('r.rid', $role->rid)
    ->condition('n.type', 'market')
    ->isNull('gr.uid');
  db_insert('og_users_roles')
    ->from($query)
    ->execute();
}

/**
 * Drop market value mapping table and remove old markets fields.
 */
function elx_content_tool_update_7110() {
  db_drop_table('elx_content_tool_markets_map');
  field_delete_field('field_markets');
  field_delete_field('field_market_name');
}
