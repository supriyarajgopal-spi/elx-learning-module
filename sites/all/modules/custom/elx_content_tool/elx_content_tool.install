<?php

/**
 * @file
 * Migration scripts for ELX content.
 */

/**
 * Implements hook_install().
 */
function elx_content_tool_install() {
  // Mark as needing updates.
  drupal_set_installed_schema_version('elx_content_tool', SCHEMA_INSTALLED);
}

/**
 * Switch from field translations to translation nodes.
 */
function elx_content_tool_update_7100() {
  foreach (node_type_get_types() as $node_type) {
    if (variable_get("language_content_type_$node_type->type", 0) == ENTITY_TRANSLATION_ENABLED) {
      variable_set("language_content_type_$node_type->type", TRANSLATION_ENABLED);
    }
  }
}

/**
 * Create a translation node for each field translation.
 */
function elx_content_tool_update_7101(&$sandbox) {
  if (module_exists('entity_translation')) {
    if (!isset($sandbox['progress'])) {
      $sandbox['progress'] = 0;
      $query = db_select('node', 'n');
      $query->join('entity_translation', 't', 'n.nid = t.entity_id');
      $sandbox['max'] = $query
        ->condition('t.entity_type', 'node')
        ->condition('t.source', '', '<>')
        ->countQuery()
        ->execute()
        ->fetchField();
      // Load node reference fields. They need to be updated to reference the
      // translation nodes.
      $sandbox['node_references'] = array();
      foreach (field_read_fields(array('type' => 'entityreference')) as $field_name => $field) {
        if ($field['translatable'] && $field['settings']['target_type'] == 'node') {
          $sandbox['node_references'][$field_name] = $field;
        }
      }
    }
    $query = db_select('node', 'n');
    $query->join('entity_translation', 't', 'n.nid = t.entity_id');
    $result = $query
      ->fields('t')
      ->condition('t.entity_type', 'node')
      ->condition('t.source', '', '<>')
      ->range(0, 10)
      ->execute();
    foreach ($result as $translation) {
      // Load translation source node.
      $source_node = node_load($translation->entity_id);
      $author = user_load($translation->uid);
      $form_state['values']['op'] = t('Save');
      form_load_include($form_state, 'pages.inc', 'node');
      // Check for existing translation nodes.
      $translations = translation_node_get_translations($source_node->nid);
      if (isset($translations[$translation->language])) {
        $node = $translations[$translation->language];
        $node->tnid = $source_node->nid;
      }
      else {
        // If there is no existing translation node, create an empty object.
        $node = new stdClass();
      }
      $node->log = t('Converted field translation to node translation.');
      $node->type = $source_node->type;
      $node->name = $author->name;
      $node->date = format_date($translation->created, 'custom', 'Y-m-d H:i:s O');
      $node->changed = $translation->changed;
      $node->status = $translation->status;
      $node->promote = $source_node->promote;
      $node->sticky = $source_node->sticky;
      $node->comment = $source_node->comment;
      $node->language = $translation->language;
      $node->translation_source = $source_node;
      $node->title = $source_node->title;
      if (module_exists('title') && title_field_replacement_enabled('node', $source_node->type, 'title')) {
        $title = title_entity_label($source_node, 'node', $translation->language);
        if (!empty($title)) {
          $node->title = $title;
        }
      }
      // In case required fields were not translated, copy values from source
      // fields.
      field_attach_prepare_translation('node', $node, $translation->language, $source_node, $source_node->language);
      // Copy values from the translated fields.
      field_attach_prepare_translation('node', $node, $translation->language, $source_node, $translation->language);
      // Messages generated by saving a translation node will be skipped
      // because the translation node should match the entity translation,
      // including data errors. Save previous messages before starting.
      $messages = drupal_get_messages();
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        // Ensure saved messages are restored even if there is an error.
        try {
          // Save translation node.
          drupal_form_submit($node->type . '_node_form', $form_state, $node);
          $errors = form_get_errors();
          if (!empty($errors)) {
            throw new DrupalUpdateException(implode("\n", $errors));
          }
          // Restore saved messages.
          $_SESSION['messages'] = $messages;
        }
        catch (Exception $e) {
          // Restore saved messages.
          $_SESSION['messages'] = $messages;
          throw $e;
        }
        // Check for successful translation node creation.
        if (isset($node->tnid) && $node->tnid == $source_node->nid) {
          // Make sure original translation status is saved.
          if (empty($node->translate) && !empty($translation->translate) || !empty($node->translate) && $node->translate != $translation->translate) {
            $node->translate = $translation->translate;
            translation_node_update($node);
          }
          // Update node references in this language to point to the translation
          // node.
          foreach ($sandbox['node_references'] as $field_name => $field) {
            $query = new EntityFieldQuery();
            $result = $query
              ->fieldCondition($field, 'target_id', $node->tnid)
              ->fieldLanguageCondition($field, $translation->language)
              ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT')
              ->execute();
            foreach ($result as $entity_type => $entities) {
              field_attach_load($entity_type, $entities, FIELD_LOAD_CURRENT, array('field_id' => $field['id']));
              foreach ($entities as $entity) {
                foreach ($entity->{$field_name}[$translation->language] as &$item) {
                  if ($item['target_id'] == $node->tnid) {
                    $item['target_id'] = $node->nid;
                  }
                }
                field_attach_update($entity_type, $entity);
              }
              entity_get_controller($entity_type)->resetCache();
            }
          }
          // Remove entity translation.
          $handler = entity_translation_get_handler('node', $source_node);
          $source_node->original = $source_node;
          $handler->removeTranslation($translation->language);
          entity_translation_sync('node', $source_node);
          $handler->updateTranslations();
          $handler->saveTranslations();
          ++$sandbox['progress'];
        }
        else {
          throw new DrupalUpdateException('Failed to create translation node.');
        }
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
    }
    if (!empty($sandbox['max'])) {
      $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
    }
  }
}

/**
 * Add markets group to content types containing field_markets.
 */
function elx_content_tool_update_7102(&$sandbox) {
  _elx_content_tool_add_markets_field($sandbox, 'field_markets');
}

/**
 * Add markets group to content types containing field_market_name.
 */
function elx_content_tool_update_7103(&$sandbox) {
  _elx_content_tool_add_markets_field($sandbox, 'field_market_name');
}

/**
 * Add markets field to content types.
 */
function _elx_content_tool_add_markets_field(&$sandbox, $field_name) {
  if (!isset($sandbox['progress'])) {
    $sandbox['markets'] = field_info_field('markets');
    $sandbox['field_markets'] = field_info_field($field_name);
    // Users already have a groups field.
    if (isset($sandbox['field_markets']['bundles']['user'])) {
      unset($sandbox['field_markets']['bundles']['user']);
    }
    // Count markets groups that match old markets fields.
    $sandbox['progress'] = 0;
    foreach ($sandbox['markets']['bundles'] as $entity_type => $bundles) {
      if (isset($sandbox['field_markets']['bundles'][$entity_type])) {
        $sandbox['progress'] += count(array_intersect($bundles, $sandbox['field_markets']['bundles'][$entity_type]));
      }
    }
    // Get the total number of old markets fields.
    $sandbox['max'] = array_sum(array_map('count', $sandbox['field_markets']['bundles']));
  }
  $count = 0;
  foreach ($sandbox['field_markets']['bundles'] as $entity_type => $bundles) {
    // Add the OG markets field to bundles that do not have it.
    foreach (array_diff($bundles, isset($sandbox['markets']['bundles'][$entity_type]) ? $sandbox['markets']['bundles'][$entity_type] : array()) as $bundle) {
      $og_field = og_fields_info('og_group_ref');
      $og_field['instance']['label'] = 'Markets';
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        og_create_field('markets', $entity_type, $bundle, $og_field);
        ++$sandbox['progress'];
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
      if (++$count == 10) {
        break 2;
      }
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Add groups content access field to content types containing markets.
 */
function elx_content_tool_update_7104(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['access'] = field_info_field(OG_CONTENT_ACCESS_FIELD);
    $sandbox['markets'] = field_info_field('markets');
    // Users are not content.
    if (isset($sandbox['markets']['bundles']['user'])) {
      unset($sandbox['markets']['bundles']['user']);
    }
    // Count OG markets fields that match old markets fields.
    $sandbox['progress'] = 0;
    foreach ($sandbox['access']['bundles'] as $entity_type => $bundles) {
      if (isset($sandbox['markets']['bundles'][$entity_type])) {
        $sandbox['progress'] += count(array_intersect($bundles, $sandbox['markets']['bundles'][$entity_type]));
      }
    }
    // Get total number of old markets fields.
    $sandbox['max'] = array_sum(array_map('count', $sandbox['markets']['bundles']));
  }
  $count = 0;
  foreach ($sandbox['markets']['bundles'] as $entity_type => $bundles) {
    // Add groups access field to bundles that do not have it.
    foreach (array_diff($bundles, isset($sandbox['access']['bundles'][$entity_type]) ? $sandbox['access']['bundles'][$entity_type] : array()) as $bundle) {
      // Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        og_create_field(OG_CONTENT_ACCESS_FIELD, $entity_type, $bundle);
        ++$sandbox['progress'];
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
      if (++$count == 10) {
        break 2;
      }
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Set content visibility.
 */
function elx_content_tool_update_7105(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['field'] = field_info_field(OG_CONTENT_ACCESS_FIELD);
    $sandbox['table'] = _field_sql_storage_tablename($sandbox['field']);
    // Get the number of content visibility values.
    $query = new EntityFieldQuery();
    $sandbox['progress'] = $query
      ->fieldCondition(OG_CONTENT_ACCESS_FIELD)
      ->count()
      ->execute();
    $sandbox['max'] = 0;
    foreach ($sandbox['field']['bundles'] as $entity_type => $bundles) {
      // Get the total number of entities containing the groups content access
      // field.
      $query = new EntityFieldQuery();
      $sandbox['max'] += $query
        ->entityCondition('entity_type', $entity_type)
        ->entityCondition('bundle', $bundles)
        ->count()
        ->execute();
    }
  }
  foreach ($sandbox['field']['bundles'] as $entity_type => $bundles) {
    $info = entity_get_info($entity_type);
    // Find an entity that is missing its content visibility setting.
    $query = db_select($info['base table'], 'b');
    $alias = $query->join($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = %alias.entity_id AND %alias.entity_type = :entity_type AND %alias.bundle IN(:bundles)', array(
      ':entity_type' => $entity_type,
      ':bundles' => $bundles,
    ));
    $query
      ->fields('b', array($info['entity keys']['id']))
      ->condition(db_or()
        ->condition("$alias.deleted", 1)
        ->isNull("$alias.entity_id")
      )
      ->range(0, 10);
    foreach (entity_load($entity_type, $query->execute()->fetchCol()) as $entity) {
      // Save content visibility. Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
        if (!isset($vid)) {
          $vid = $id;
        }
        db_insert($sandbox['table'])
          ->fields(array(
            'entity_type' => $entity_type,
            'entity_id' => $id,
            'revision_id' => $vid,
            'bundle' => $bundle,
            'delta' => 0,
            'language' => LANGUAGE_NONE,
            _field_sql_storage_columnname(OG_CONTENT_ACCESS_FIELD, 'value') => OG_CONTENT_ACCESS_DEFAULT,
          ))
          ->execute();
        // Add new content visibility setting to processed count.
        ++$sandbox['progress'];
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Create table to map old market options to new market groups.
 */
function elx_content_tool_update_7106() {
  // Use a transaction so we can clean up errors.
  $transaction = db_transaction();
  try {
    db_create_table('elx_content_tool_markets_map', array(
      'description' => 'Temporary table to map market options to market groups.',
      'fields' => array(
        'market' => array(
          'description' => 'Old markets value.',
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
        ),
        'nid' => array(
          'description' => 'Market group {node}.nid.',
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'default' => 0,
        ),
      ),
      'primary key' => array('market'),
    ));
    // Map old market options to new market groups.
    $query = db_insert('elx_content_tool_markets_map')
      ->fields(array('market', 'nid'));
    $market_options = array();
    foreach (array('field_markets', 'field_market_name') as $field_name) {
      $field_markets = field_info_field($field_name);
      if (isset($field_markets['settings']['allowed_values'])) {
        $market_options += $field_markets['settings']['allowed_values'];
      }
    }
    foreach ($market_options as &$name) {
      if ($name = 'Travel Retail Middle Pacific') {
        $name = 'TR Mid-Pac';
      }
      elseif (strpos($name, 'Travel Retail ') === 0) {
        $name = substr_replace($name, 'TR ', 0, 14);
      }
    }
    // Handle market typos.
    $market_options['Colombia-Ecuador-Central America '] = 'Colombia - Ecuador - Central America';
    $market_options['Eau Claire'] = 'Eau Claire';
    $market_options['en'] = 'United States';
    $market_options['English'] = 'United States';
    $market_options['Ireland'] = 'Ireland';
    $market_options['KRn'] = 'Korea';
    $market_options['NOAM'] = 'TR Americas - North America';
    $market_options['Southern Cone-Chile-Peru-Argentina'] = 'Southern Cone - Chile - Peru - Argentina';
    $market_options['TR MY'] = 'TR Malaysia';
    $market_options['TR SG'] = 'TR Singapore';
    $market_options['TR TH'] = 'TR Thailand';
    $market_options['Travel Retail CN'] = 'TR China';
    $market_options['Travel Retail HK-Macau-TW'] = 'TR Hong Kong-Macau-Taiwan';
    $market_options['Travel Retail JP'] = 'TR Japan';
    $market_options['Travel Retail KR'] = 'TR Korea';
    $market_options['TRRAM-CC'] = 'TR Americas - Caribbean - Cancun';
    $market_options['U.K.'] = 'U.K.';
    $market_options['unisted states'] = 'United States';
    $market_options['ZAe'] = 'South Africa';
    $market_groups = db_select('node', 'n')
      ->fields('n', array('title', 'nid'))
      ->condition('n.type', 'market')
      ->execute()
      ->fetchAllKeyed();
    foreach ($market_options as $option => $name) {
      if (isset($market_groups[$name])) {
        $query->values(array(
          'market' => $option,
          'nid' => $market_groups[$name],
        ));
      }
    }
    $query->execute();
  }
  catch (Exception $e) {
    $transaction->rollback();
    throw $e;
  }
}

/**
 * Switch old field_markets values to new markets groups.
 */
function elx_content_tool_update_7107(&$sandbox) {
  _elx_content_tool_market_switch($sandbox, 'field_markets');
}

/**
 * Switch old field_market_name values to new markets groups.
 */
function elx_content_tool_update_7108(&$sandbox) {
  _elx_content_tool_market_switch($sandbox, 'field_market_name');
}

/**
 * Switch old markets field values to new markets group.
 */
function _elx_content_tool_market_switch(&$sandbox, $field_name) {
  if (!isset($sandbox['progress'])) {
    $sandbox['field'] = field_info_field($field_name);
    $sandbox['table'] = _field_sql_storage_tablename($sandbox['field']);
    $sandbox['column'] = _field_sql_storage_columnname($field_name, 'value');
    $sandbox['role'] = user_role_load_by_name('EL Regional Market Admin');
    $sandbox['rid'] = array_search(OG_ADMINISTRATOR_ROLE, og_roles('node', 'market'));
    $sandbox['progress'] = 0;
    $sandbox['max'] = 0;
    foreach ($sandbox['field']['bundles'] as $entity_type => $bundles) {
      $info = entity_get_info($entity_type);
      // Get the number of values that have been switched to market groups.
      $query = db_select($info['base table'], 'b');
      $query->join($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', "f.$sandbox[column] = s.market");
      $query->join('og_membership', 'g', 'b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid');
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $sandbox['progress'] += $query
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->condition('g.entity_type', $entity_type)
        ->condition('g.state', 1)
        ->countQuery()
        ->execute()
        ->fetchField();
      // Get the total number of old market values.
      $query = db_select($info['base table'], 'b');
      $query->join($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', "f.$sandbox[column] = s.market");
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $sandbox['max'] += $query
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->countQuery()
        ->execute()
        ->fetchField();
    }
  }
  foreach ($sandbox['field']['bundles'] as $entity_type => $bundles) {
    $field_name = $entity_type == 'user' ? 'og_user_node' : 'markets';
    $info = entity_get_info($entity_type);
    // Find an entity that is missing market groups.
    $query = db_select($info['base table'], 'b');
    $query->join($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
    $query->join('elx_content_tool_markets_map', 's', "f.$sandbox[column] = s.market");
    $query->leftJoin('og_membership', 'g', 'g.entity_type = :entity_type AND b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid', array(
      ':entity_type' => $entity_type,
    ));
    if (isset($info['entity keys']['language'])) {
      $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
    }
    $query
      ->fields('b', array($info['entity keys']['id']))
      ->condition('f.entity_type', $entity_type)
      ->condition('f.deleted', 0)
      ->condition(db_or()
        ->condition('g.state', 0)
        ->isNull('g.etid')
      )
      ->range(0, 10);
    foreach (entity_load($entity_type, $query->execute()->fetchCol()) as $entity) {
      // Get new market groups to add.
      $query = db_select($info['base table'], 'b');
      $query->join($sandbox['table'], 'f', 'b.' . $info['entity keys']['id'] . ' = f.entity_id');
      $query->join('elx_content_tool_markets_map', 's', "f.$sandbox[column] = s.market");
      $query->leftJoin('og_membership', 'g', 'g.entity_type = :entity_type AND b.' . $info['entity keys']['id'] . ' = g.etid AND s.nid = g.gid', array(
        ':entity_type' => $entity_type,
      ));
      if (isset($info['entity keys']['language'])) {
        $query->where('b.' . $info['entity keys']['language'] . ' = f.language');
      }
      $markets = $query
        ->fields('s', array('nid'))
        ->condition('f.entity_type', $entity_type)
        ->condition('f.deleted', 0)
        ->condition(db_or()
          ->condition('g.state', 0)
          ->isNull('g.etid')
        )
        ->condition('b.' . $info['entity keys']['id'], $entity->{$info['entity keys']['id']})
        ->execute()
        ->fetchCol();
      // Set market groups.
      foreach ($markets as $nid) {
        $entity->{$field_name}[LANGUAGE_NONE][] = array('target_id' => $nid);
      }
      // Clear entity cache.
      entity_get_controller($entity_type)->resetCache(array(
        $entity->{$info['entity keys']['id']},
      ));
      // Save market groups. Use a transaction so we can clean up errors.
      $transaction = db_transaction();
      try {
        foreach ($markets as $nid) {
          $og_membership = og_membership_create('node', $nid, $entity_type, $entity->{$info['entity keys']['id']}, $field_name, array('language' => LANGUAGE_NONE));
          $og_membership->entity = $entity;
          $og_membership->save();
          // Assign market admin.
          if ($entity_type == 'user' && user_has_role($sandbox['role']->rid)) {
            if (isset($sandbox['rid'])) {
              og_role_grant('node', $nid, $entity->uid, $sandbox['rid']);
            }
          }
          // Add new market group to processed count.
          ++$sandbox['progress'];
        }
      }
      catch (Exception $e) {
        $transaction->rollback();
        throw $e;
      }
    }
  }
  if (!empty($sandbox['max'])) {
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Drop market value mapping table and remove old markets fields.
 */
function elx_content_tool_update_7109() {
  db_drop_table('elx_content_tool_markets_map');
  field_delete_field('field_markets');
  field_delete_field('field_market_name');
}
