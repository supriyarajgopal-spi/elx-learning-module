<?php

/**
 * Identifies languages.
 * 
 * @return
 *   returns an array with interface language, 
 *   user language if logged in and 
 *   HTTP_ACCEPT_LANGUAGE modified to fit ELX site languages
 * 
 */
function elx_language_detect() {
  global $language;
  global $user;
  // interface language
  $interface_lang = isset($language->language) ? $language->language : FALSE;
  $lang['interface_language'] = $interface_lang;
  
  // user choosen language
  if ($user->uid) {
    $user_lang = $user->language;
	$lang['user_language'] = $user_lang;
  }
  else {
  	$user_lang = FALSE;
	$lang['user_language'] = FALSE;
  }

  // Identify language from the Accept-language HTTP header we got.
  // http_accept_language
  $accept_lang = !empty($_SERVER['HTTP_ACCEPT_LANGUAGE']) ? $_SERVER['HTTP_ACCEPT_LANGUAGE'] : FALSE;
  $replace_str = strstr($accept_lang, ",");
  $accept_lang = str_replace($replace_str, '', $accept_lang);
  //$accept_lang_array = [str_replace('-', '', $accept_lang)];
  $accept_lang_array = [$accept_lang];
  
  $supported = ['ar', 'cs', 'da', 'de', 'el', 'en', 'es-SP', 'es',  
      'fi', 'fr-CA', 'fr', 'he', 'hu', 'id', 'it', 'ja', 'ko', 'lt', 'lv', 'mo',
      'nb', 'nl', 'nn', 'no', 'pl', 'ro', 'ru', 'sv', 'th', 'tr', 'zh-CN', 'zh-TW', 
      'zh-Hans', 'zh-Hant', 'zhHans', 'zhHant', 'zh'];

  print_r(' LANG MATCH before the match ');
  print_r($accept_lang_array);
  
  $lang_match = elx_language_find_match($supported, $accept_lang_array);
  
  print_r(' LANG MATCH before the ifs ');
  print_r($lang_match);
  
  // french-canadian
  if ($lang_match === 'fr-CA') {
    $lang_match = 'frca';
  }
  // spanish
  if ($lang_match === 'es-SP') {
    $lang_match = 'essp';
  }
  // [mo] for Moldavian has been withdrawn, recommending [ro] also for Moldavian
  if ($lang_match === 'mo') {
    $lang_match = 'ro';
  }
  // nn and no also Norwegian
  if ($lang_match === 'nn' || $lang_match === 'no') {
    $lang_match = 'nb';
  }
  // Chinese -> Traditional Chinese (FF only sends 'zh').
  if ($lang_match === 'zh') {
    $lang_match = 'zhHant';
  }
  // zh-CN is much more common code for Simplified Chinese.
  if ($lang_match === 'zh-CN') {
    $lang_match = 'zhHans';
  }
  // zh-TW is much more common code for Traditional Chinese.
  if ($lang_match == 'zh-TW') {
    $lang_match = 'zhHant';
  }
  // Default to english.
  if (!$lang_match) {
    $lang_match = 'en';
  }
  $lang['http_accept'] = $lang_match;
  
  dpm($interface_lang);
  dpm(' accept lang ');
  dpm($accept_lang);
  dpm(' user lang ');
  dpm($user_lang);

  print_r($interface_lang);
  print_r(' accept lang ');
  print_r($accept_lang);
  print_r(' user lang ');
  print_r($user_lang);

  var_dump($lang);
  return $lang;
}

function elx_language_find_match($supported, $accepted) {
  for ($i = 0; $i < count($accepted); $i++) {
    $accepted_2 = $accepted[$i];
    if (strpos($accepted_2, '-') > 0) {
      $accepted_2 = substr($accepted_2, 0, strpos($accepted_2, '-'));
    }

    for ($j = 0; $j < count($supported); $j++) {
      if ($accepted[$i] === $supported[$j]) {
        return $accepted[$i];
      }

      if ($accepted_2 === $supported[$j]) {
        return $accepted_2;
      }
    }
  }
  return false;
}

/*
 * function for what languages ELX supports
 * 
 * @params
 * $lang - user's choosen language
 * 
 * @return
 * returns true if language is supported or false if not
 */
function elx_languages_supported($lang) {
  $supported = ['ar', 'cs', 'da', 'de', 'el', 'en', 'es-SP', 'es',  
      'fi', 'fr-CA', 'fr', 'he', 'hu', 'id', 'it', 'ja', 'ko', 'lt', 'lv', 'mo',
      'nb', 'nl', 'nn', 'no', 'pl', 'ro', 'ru', 'sv', 'th', 'tr', 'zh-CN', 'zh-TW', 
      'zh-Hans', 'zh-Hant', 'zhHans', 'zhHant', 'zh'];
	  
  if (in_array($lang, $supported)) {
  	return TRUE;
  }
  else {
  	return FALSE;
  }
}

/*
 *  function - parse json language files
 * 
 *  @params
 *  $lang - user's choosen language
 *  $key_vars - an array of keys we need translated
 * 
 *  @return
 *  returns an array of string translations based on lang param
 */
function elx_languages_get_translations($lang, $key_vars) {
  global $base_url;
  $file_name = $lang . '.json';
  $json_path = $base_url . '/sites/all/themes/locales/' . $file_name;
  $json_locale_file = file_get_contents($json_path);
  $json_array = json_decode($json_locale_file, true);
  $val_array = array();
  foreach ($key_vars as $key) {
  	if(array_key_exists($key, $json_array)) {
      //key exists, do stuff
	  $val = $json_array[$key];
	  $val_array[$key] = $val;
    }

  }
  return $val_array;
}

/**
 *  Script for parsing the locale json files into a po file format for Drupal to use
 */
function elx_languages_json_to_po() {
  global $base_url;
  //TODO** Change static path to relative path of server
  $json_path = '/Users/tmyers/Documents/SPI/elx-learning-module/sites/all/themes/locales/';
  $fileSystemIterator = new FilesystemIterator($json_path);

  $entries = array();
  foreach ($fileSystemIterator as $fileInfo){
    $entries[] = $fileInfo->getFilename();
	$file_path = $fileInfo->getPathname();
	$json_locale_file = file_get_contents($file_path);
	$json_array = json_decode($json_locale_file, true);
	$json_file_name = $fileInfo->getFilename();
	$po_file_name = str_replace('.json', '.po', $json_file_name);
	//TODO** Change the static path to relative path of server
	$new_file_path = '/Users/tmyers/Documents/SPI/elx-learning-module/sites/all/themes/po_files/' . $po_file_name;
	//$new_file_path = './po_files/' . $po_file_name;

	$po_file = fopen($new_file_path, 'w') or die('Unable to open file!');
	foreach($json_array as $key => $value) {
	  $po_key = str_replace(' ', '_', $key);
	  $file_text = '#: /' . "\r\n" . 
                    'msgid "'. $po_key .'"' . "\r\n" . 
                    'msgstr "' . $value . '"' . "\r\n" ."\r\n";
	  fwrite($po_file, $file_text);
    }
  }
  return TRUE;
}