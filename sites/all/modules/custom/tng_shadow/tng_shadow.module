<?php


/**
 * @param $entity - This view entity is passed
 * from the shadow module to construct a valid JSON object that the NewPlayerV2 can consume.
 * We process the paragraph portion since shadowed entities does not.
 *
 * We loop through the 'field_xyz' pieces which came from field_info_instances element_children.
 *
 *   for (each field we find)
 *     go through each element child and look for a paragraph type
 *       if (it is a paragraph)
 *         loop through it to find all pairs of questions and possible multiple answers
 *          note this information in the manifest object
 *       else
 *         note the node and data in our manifest object
 *   end
 */

function tng_shadow_shadow_request_alter($entity) {

  try {
    //dpm ($entity);
    $entity_array = (array) $entity;
    dpm ($entity_array);
    $language = $entity->path['language'];
    dpm($language);
    global $namevalue;
    $manifest = array();
    //$size_of_entity_array = count($entity_array);
    //dpm('number of array elements : ' . $size_of_entity_array    );
    // load the current entity in a wrapper
    $wrapper = entity_metadata_wrapper('node', $entity);
    //dpm(_wrapper_debug($wrapper));
    // given our node entity type, get all the fields for it
    $entity_type = $entity->type;
    //dpm($size_of_entity_array . ' ' . $entity_type . ' elements in the node type');

    // field_info_instances holds the field values at the outermost level
    // paragraph types must be explored more, 'regular' value fields are written as is.
    $node_fields = field_info_instances('node', $entity_type);
    //dpm($node_fields);
    $number_of_fields = count($node_fields);
    dpm('found ' . $number_of_fields . ' ' . $entity_type . ' fields ');
    $children_nodes_to_process = element_children($node_fields);
    //dpm($children_nodes_to_process[0]);
    // we loop through the fields looking for a paragraph type to expand and rewrite
    for ($i=0; $i < $number_of_fields; $i++) {
      dpm('['. $i .']:' . $children_nodes_to_process[$i]);
      // first field is the 'field_paragraph_multiple_choice'
      $namevalue = '"' . $children_nodes_to_process[$i] . '" : "' ;

      //dpm($children_nodes_to_process[$i]);
      //dpm($wrapper->$children_nodes_to_process[$i]->value());
      $info = field_info_field($children_nodes_to_process[$i]);
      //dpm($info);
      // $info['field_name'] is the name of the paragraph
      if ($info['type'] == 'paragraphs') {
        // if we have a paragraphs type, use a wrapper for easier reference
        $paragraphs = $wrapper->$info['field_name']->value();
        //dpm($paragraphs);
        $number_of_paragraphs = count($wrapper->$info['field_name']->value());
        dpm($number_of_paragraphs . ' ' . $info['field_name']  . ' paragraphs found.');
        $namevalue = $namevalue .  '[';
        // using the paragraphs bundle type, we can get all the fields we need to account for in our data
        $paragraph_fields = field_info_instances('paragraphs_item', $paragraphs->bundle);
        $number_of_paragraph_fields = count($paragraph_fields);
        //dpm($paragraph_fields);
        dpm($number_of_paragraph_fields . $paragraph_fields['field_name'] . ' paragraph fields found.');
        $children_fields_to_process = element_children($paragraph_fields);
        // explore each paragraph
        for ($p=0; $p < $number_of_paragraphs; $p++) {
          // and every field for each paragraph
          for ($pf=0; $pf < $number_of_paragraph_fields; $pf++) {
            // inside the fields within a paragraph the language variable is not used, it's 'und'
            $language = 'und';
            $field_name = $children_fields_to_process[$pf];
            dpm($field_name);
            $field_child_info = field_info_field($children_fields_to_process[$pf]);
            //dpm('fi');
            //dpm($field_child_info);
            $name = $field_child_info['field_name'];
            if (isset($paragraphs->{$name}[$language][0]['value'])) {
              $namevalue = $namevalue . '{"' . $field_name . '" : "' . $paragraphs->{$name}[$language][0]['value']. '"},';
            } else {
              $namevalue = $namevalue . '{"' . $field_name . '" : ' . '""},';
            }
            //$field_info = $paragraphs->{$name}[$language][0]['value'];
            //dpm($field_info);
            //$num
            $field_count = count($paragraphs->{$name}[$language]);
            // if there are no elements in the field don't process
            if ($field_count < 1) {
              continue;
            } else {
              // typical question
              dpm($field_count .  ' field(s) sets found for ' . $paragraphs->{$name}[$language][0]['value']);
              if (($field_count == 1) && (isset($paragraphs->{$name}[$language][0]['value']))) {
                dpm('name : '. $name . ' value : ' . $paragraphs->{$name}[$language][0]['value']);
              } else {
                // typically answers
                for ($f=0; $f < $field_count; $f++) {
                  $entity = paragraphs_item_load($paragraphs->{$name}[$language][$f]['value']);
                  //dpm($entity);
                  $para_inst = field_info_instances('paragraphs_item', $entity->bundle());
                  //dpm($para_inst);
                  $sub_children = element_children($para_inst);
                  foreach ($sub_children as $key=>$value) {
                    //dpm($key);
                    // if the value for a field is set, we will output it (and skip blank fields)
                    if (isset($entity->{$value}[$language][0]['value'])) {
                      dpm($value);
                      dpm($entity->{$value}[$language][0]['value']);
                      $namevalue = $namevalue . '{"' . $value . '":"' . $entity->{$value}[$language][0]['value'] . '"},';
                    }
                    $info = field_info_field($sub_children[$key]);
                    //dpm($info);
                    // expect 'file' or 'image' here
                    $field_name = $value;
                    if ($info['type'] == 'image') {
                      $image_style = $node_fields[$field_name]['display']['default']['settings']['image_style'];
                      $fid = $entity_array[$field_name][$language][0]['fid'];
                      if ($fid) {
                        $file_id = file_load($fid);
                        $uri = $file_id->uri;
                        $image_style_path = image_style_url($image_style, $uri);
                      } else {
                        $image_style_path = '';
                      }
                      dpm($field_name . ': ' . $image_style_path);
                    }
                    if ($info['type'] == 'taxonomy_term_reference') {
                      $number_of_terms = count($entity_array[$field_name][$language]);
                      dpm($field_name);
                      for ($t=0; $t < $number_of_terms; $t++) {
                        $tids = array($entity_array[$field_name][$language][$t]['tid']);
                        $terms = taxonomy_term_load_multiple($tids);
                        foreach ($terms as $term) {
                          $name = $term->name;
                          dpm($name);
                        }
                      }
                    }
                  }
                  //dpm('name end inner for'. $namevalue);
                }
                //dpm('name end outer for'. $namevalue);
              }
            }
          }
        }
        // remove the final ',' and add the final ']' to be syntax correct on the json
        $namevalue = trim($namevalue, ",") . ']"';
        $manifest[]  = $namevalue;
        dpm($namevalue);
      }
      elseif ($info['type'] == 'entityreference') {
        dpm($info);
        dpm('found an entity reference node to fetch and process');
      }
      elseif ($info['type'] == 'image') {
        dpm('found an outer node image');
        $field_name = $info['field_name'];
        $image_style = $node_fields[$field_name]['display']['default']['settings']['image_style'];
        $fid = $entity_array[$field_name][$language][0]['fid'];
        if ($fid) {
          $file_id = file_load($fid);
          $uri = $file_id->uri;
          $image_style_path = image_style_url($image_style, $uri);
        } else {
          $image_style_path = '';
        }
        dpm($field_name . ': ' . $image_style_path);
      }
      elseif ($info['type'] == 'file') {
        dpm('found an outer node file');
        $field_name = $info['field_name'];
        $fid = $entity_array[$field_name][$language][0]['fid'];
        $file_id = file_load($fid);
        $uri = $file_id->uri;
        dpm($field_name . ': ' . file_create_url($uri));
      }
      elseif ($info['type'] == 'taxonomy_term_reference') {
        dpm('found a taxonomy term reference');
        $field_name = $info['field_name'];
        $number_of_terms = count($entity_array[$field_name][$language]);
        dpm($field_name);
        for ($t=0; $t < $number_of_terms; $t++) {
          $tids = array($entity_array[$field_name][$language][$t]['tid']);
          $terms = taxonomy_term_load_multiple($tids);
          foreach ($terms as $term) {
            $name = $term->name;
            dpm($name);
          }
        }
      }
      elseif (($info['type']== 'list_text') || ($info['type']== 'list_boolean')) {
        dpm("arriving");
        dpm($namevalue);
        $namevalue  = $namevalue . $entity_array[$children_nodes_to_process[$i]]['und'][0]['value'];
        dpm('list_text');
        dpm($namevalue);
        $manifest[] = $namevalue;
      }
      else {
        dpm('not a paragraph, image or taxonomy term reference, saving value on object : '. $info['type']);
        dpm($info);
        // if we have a title, it is language specific, if not use $language
        if ($children_nodes_to_process[$i] == 'title_field') {
          dpm($entity_array[$children_nodes_to_process[$i]][$entity_array['language']][0]['value']);
          //dpm($namevalue);
          $namevalue = $namevalue . $entity_array[$children_nodes_to_process[$i]][$entity_array['language']][0]['value'];
          //dpm($namevalue);
          $manifest[]  = $namevalue;
        } else {
          //dpm($entity_array[$children_nodes_to_process[$i]][$language][0]['value']);
          //dpm($namevalue);
          $namevalue  = $namevalue . $entity_array[$children_nodes_to_process[$i]][$language][0]['value'];
          //dpm($namevalue);
          $manifest[] = $namevalue;
        }
      }
    }

    dpm($manifest);
    $json = json_encode($manifest);
    dpm($json);

//    $moredeet = '[{"field_difficulty":"2"},{"field_is_required":"1"},{"field_paragraph_multiple_choice":"[{\"field_question_text\" : \"What is 2+2?\"},{\"field_question_media\" : \"\"}, {\"field_question_video\" : \"\"},{\"field_video_poster_image\": \"\"}, {\"field_paragraph_answer\": \"[{\'field_answer_text\' : \'3\'},{\'field_answer_feedback\' : \'nope\'},{\'field_correct_answer\' : \'0\'}],[{\'field_answer_text\' : \'2\'},{\'field_answer_feedback\' : \'no!\'},{\'field_correct_answer\' : \'0\'}],[{\'field_answer_text\' : \'4\'},{\'field_answer_feedback\' : \'yes\'},{\'field_correct_answer\' : \'1\'}]\"},{\"field_question_text\" : \"What is the meaning of life?\"},{\"field_question_media\" : \"\"}, {\"field_question_video\" : \"\"},{\"field_video_poster_image\": \"\"}, {\"field_paragraph_answer\": \"[{\'field_answer_text\' : \'4\'},{\'field_answer_feedback\' : \'sorry, no\'},{\'field_correct_answer\' : \'0\'}],[{\'field_answer_text\' : \'2\'},{\'field_answer_feedback\' : \'nope\'},{\'field_correct_answer\' : \'0\'}],[{\'field_answer_text\' : \'42\'},{\'field_answer_feedback\' : \'yes, correct\'},{\'field_correct_answer\' : \'1\'}]\"}]"},{"title_field":"Test Multiple Choice"}]';
//    dpm($moredeet);
//    $undeet = json_decode($moredeet);
//    dpm('more decoded');
//    dpm($undeet);



    //return $my_object;
  }
  catch (exception $e) {
    dpm($e);
  }

}

function array_to_obj($array, &$obj)
{
  foreach ($array as $key => $value)
  {
    if (is_array($value))
    {
      $obj->$key = new stdClass();
      array_to_obj($value, $obj->$key);
    }
    else
    {
      $obj->$key = $value;
    }
  }
  return $obj;
}

function arrayToObject($array)
{
  $object= new stdClass();
  return array_to_obj($array,$object);
}

function _wrapper_debug($w) {
  $values = array();
  foreach ($w->getPropertyInfo() as $key => $val) {
    $values[$key] = $w->$key->value();
  }
  return $values;
}
