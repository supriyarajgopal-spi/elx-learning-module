<?php

function tng_process_entity () {

}
/**
 * @param $targetid - a target_id value
 *
 * tng_title_and_image_extractor - will load the node for the passed target_id and hand back an array
 *  of pairs of data:
 *    - headline (or product name for products)
 *    - thumbnail image of the referenced product
 *
 */
function tng_title_and_image_extractor ($targetid) {
  try {
    $title = 'title_field';
    $image = 'field_product_image';
    $results = array();
    $entity = node_load($targetid);
    $language = $entity->language;
    $product_title = $entity->title_field[$language][0]['value'];
    dpm($product_title);
    $results[$title] = $product_title;
    $thumb = $entity->field_product_image[$language][0]['uri'];
    dpm('***thumb***'. $thumb);
    $results[$image] = $thumb;
    return $results;
  }
  catch (exception $e) {
    dpm($e);
  }
}



/**
 * @param $id = required parameter for creating an npFeature for NewPlayerV2
 * @param null $req = if there is a required css library, pass it in here, default is null
 * @param null $version = if there is a version number given, embed it here
 * @param null $timestamp = if there is an assigned date, use it, otherwise creation from current time.
 *
 * tng_npFeature_maker - given the required parameter $id, build a valid npFeature code chunk
 */
function tng_npFeature_maker($id, $req = NULL, $version = NULL, $timestamp = NULL) {
  try {
    dpm('beginning npFeature code');
    if (isset($id)) {
      if (!isset($req)) {
        $req = '["../../../assets/anr.css"]';
      }
      if (!isset($version)) {
        $version = '"0.0.1"';
      }
      if (!isset($timestamp)) {
        $format_string = 'Y-M-D_h:m:s';
        $time_string = date ($format_string);
        dpm($time_string);
      }
      $feature = '[ {';
      $feature = $feature . '"type"' . ':' . '"npFeature"' ;
      $feature = $feature . ',' . '"data"' . ': {' .  '"id"' . ': ' . '"' . $id . '"';
      $feature = $feature . ',' . '"req"' . ': ' . $req;
      $feature = $feature . ',' . '"version"' . ': '  . '"'. $version. '"';
      $feature = $feature . ',' . '"timestamp"' . ': '  . '"' . $time_string . '"';
      $feature = $feature . '},';
      dpm('feature string');
      dpm($feature);
      return $feature;
    } else {
      dpm('No id passed to npFeature function!');
      return null;
    }
  }

  catch (exception $e) {
    dpm($e);
  }

}

/**
 * @param $id = required parameter for creating an npContent for NewPlayerV2
 * @param null $language = required parameter to set the language for the page content
 * @param null $title = set the page title
 * @param null $description = set the page description
 *
 * tng_npContent_maker - given the required parameter $id, build a valid npContent code chunk
 */
function tng_npContent_maker($id, $language, $title = NULL, $description = NULL) {
  try {
    dpm('beginning npContent code');
    if (isset($id) && isset($language)) {
      if (!isset($title)) {
        $title = '"Sample Manifest Content Title"';
      }
      if (!isset($description)) {
        $description = '"Sample presentation"';
      }
      $content = '"components": [ {';
      $content = $content . '"type"' . ':' . '"npContent"' ;
      $content = $content . ',' . '"data"' . ': {' .  '"id"' . ': ' .'"' .  $id . '"';
      $content = $content . ',' . '"language"' . ': ' . '"' . $language . '"' ;
      $content = $content . ',' . '"title"' . ': '  .'"' . $title . '"' ;
      $content = $content . ',' . '"description"' . ': ' . '"' . $description .' "' ;
      $content = $content . '},';
      dpm('content string');
      dpm($content);
      return $content;
    } else {
      dpm('No id or language passed to npContent function!');
      return null;
    }
  }

  catch (exception $e) {
    dpm($e);
  }

}


/**
 * @param $id = required parameter for creating an npPage for NewPlayerV2
 * @param null $parentid = set the parent id for a page relationship
 * @param null $title = set the page title
 * @param null $required = set the page description
 *
 * tng_npPage_maker - given the required parameter $id, build a valid npPage code chunk
 */
function tng_npPage_maker($id, $parentid = NULL, $title = NULL,  $required = NULL) {
  try {
    dpm('beginning npPage code');
    if (isset($id)) {
      if (!isset($title)) {
        $title = '"Page Title"';
      }
      if (!isset($required)) {
        $required = 'false';
      }
      $page = '"components": [ {';
      $page = $page . '"type"' . ':' . '"npPage"' ;
      $page = $page . ',' . '"data"' . ': {' .  '"id"' . ': '  . '"' .  $id . '"';
      $page = $page . ',' . '"parentId"' . ': ' .'"' . $parentid .'"' ;
      $page = $page . ',' . '"title"' . ': ' .'"' . $title.'"' ;
      $page = $page . ',' . '"required"' . ': '  . $required ;
      $page = $page . '}, ';
      $page = $page . '"components": [';
      dpm('page string');
      dpm($page);
      return $page;
    } else {
      dpm('No id passed to npPage function!');
      return null;
    }
  }

  catch (exception $e) {
    dpm($e);
  }

}


/**
 * @param $id = div id (for data, not header id) used for css styling later
 * @param null $class = define a class for the HTML element, for example 'field-label'
 * @param null $headerlabel = each header section needs a label to style, slightly confusing it is the 'content' of the header
 * @param null $content = typically the raw HTML for the <div>
 * @return null|string = returns an NewPlayerV2 string of nice json for an HTML element
 */


function tng_npHTML_maker($id, $class = NULL, $headerlabel = NULL,  $content = NULL) {
  try {
    dpm('beginning npHTML code');
    if (isset($id)) {
      $html = '';
      $html = $html . '{' . '"type"' . ':' . '"npHTML"' ;
      $html = $html . ',' . '"data"' . ': {' .  '"id"' . ': ' . '"' . $id . 'Header'. '"';
      //$html = $html . ',' . '"parentId"' . ': ' . $parentid;
      //$html = $html . ',' . '"class"' . ': ' . '"' . $class . '"';
      $html = $html . ',' . '"plugin"' . ': ' . '"' . 'np-expandable' . '"';
      $html = $html . ',' . '"content"' . ': ' . '"' . $headerlabel . '"';
      $html = $html . '},'; // matches data line
      $html = $html . '"components"' . ': [ {'  ;
      $html = $html . '"type"' . ':' . '"npHTML"' ;
      $html = $html . ',' . '"data"' . ': {' .  '"id"' . ': ' . '"' . $id . '"';
      $html = $html . ',' . '"content"' . ': ' . '"' . $content . '"';
      $html = $html . '}, '; // matches data line
      $html = $html . '"components": [ ]';
      $html = $html . '} ] }'; // matches components line
      dpm('html string');
      dpm($html);
      return $html;
    } else {
      dpm('No id passed to npHTML function!');
      return null;
    }
  }

  catch (exception $e) {
    dpm($e);
  }

}

/**
 * @param $id - the string for the image
 * @return null|string
 */
function tng_npImage_maker($id) {
  try {
    dpm('beginning npImage code');
    if (isset($id)) {
      $image = '';
      $image = $image . '{' . '"type"' . ':' . '"npImage"' ;
      $image = $image . ',' . '"data"' . ': {' .  '"src"' . ': ' . '"' . $id . '"';
      $image = $image . '}, '; // matches data line
      $image = $image . '"components": [ ]';
      $image = $image . '}'; // matches components line
      dpm('image string');
      dpm($image);
      return $image;
    } else {
      dpm('No id passed to npImage function!');
      return null;
    }
  }

  catch (exception $e) {
    dpm($e);
  }

}

/**
 * @return string - when we create manifest objects we need to finish things with proper entity closing } and ]
 */
function tng_npPageContentFeatureCleanup() {
  $cleanup = '] ';             // close the component started in the npPage
  $cleanup = $cleanup . '} ';  // close the curly started before the npPage
  $cleanup = $cleanup . '] ';  // close the component brace started before the npPage
  $cleanup = $cleanup . '} ';  // close the component brace started before the npContent
  $cleanup = $cleanup . '] ';  // close the component bracket started before the npContent
  $cleanup = $cleanup . '} ';  // close the most outer curly brace started before the npFeature
  $cleanup = $cleanup . ']';   // close the most outer brace started before the npFeature
  return $cleanup;
}

/**
 * @param $language_key - the key to create our ISO 639-1 country and language codes, new languages should
 * be introduced here. the default language is 'en' if we can't figure out the key.
 *
 * @return array the $manifest_language returned has the language-country in the 0th element and the content line in the 1st element
 */
function make_language_strings($language_key) {
  if ($language_key == 'en') {
    $manifest_language[] = 'en-US';
    $manifest_language[] = 'content_en-US';
  } elseif ($language_key == 'zh-hant') {
    $manifest_language[] = 'zh-TW';
    $manifest_language[] = 'content_zh-TW';
  } elseif ($language_key == 'zh-hans') {
    $manifest_language[] = 'zh-CN';
    $manifest_language[] = 'content_zh-CN';
  } else {
    $manifest_language[] = 'en-US';
    $manifest_language[] = 'content_en-US';
  }
  return $manifest_language;
}

/**
 * The process_ functions are
 */

/**
 * @param $product_values - an array with key=>value pairs for the products
 *
 * the following fields have CSV values :
 *
 *  field_tags_keywords
 *  field_season
 *  field_product_category
 *
 * this field has title and image CSV sets within it  e.g. (title1,image1,title2,image2,) :
 *
 *  field_perfect_partners
 *
 */
function process_product($product_values, $language, $nid) {

  dpm('**nid**' . $nid);

  //create an npFeature, npContent, npPage, and multiple npHTML chunks to make a NP product page
  // and if we find between 1 and 17 fields, layout the page
  $min_product_fields = 1;
  $max_product_fields = 17;
  $num_fields = count($product_values);
  if ($num_fields >= $min_product_fields && $num_fields <= $max_product_fields) {
    // here we process the fields we find for our product passed in the array of $product_values
    //  start by telling the processor how many fields we found
    dpm('Product had ' . $num_fields . ' fields.');
    $title = $product_values['title_field'];
    dpm('title : ' . $title);
    $feature_chunk = tng_npFeature_maker($title, '["../../../assets/anr.css"]', '0.0.1');
    //language specific code here, we can only handle english, traditional and simplified chinese, if none of these default to english
    $language_strings = make_language_strings($language);
    $manifest_language = $language_strings[0];
    $manifest_content = $language_strings[1];
    $manifest_title = 'Product Manifest - ' . $title;
    $content_chunk = tng_npContent_maker($manifest_content, $manifest_language,  $manifest_title, 'This manifest creates a product page.');
    // for some reason, 'Welcome' is a magic title that allows the rest of the HTML pages to work.
    $page_chunk = tng_npPage_maker('Welcome', '', $title,  'true');

    $whole_product = $feature_chunk . $content_chunk . $page_chunk;

    foreach ($product_values as $key=>$value) {
      dpm('**** data ****' . $key . ' : ' . $value);

      if ($key == 'field_product_image') {
        $truth = tng_convert_drupal_to_mean_filename($value);
        $image_chunk = tng_npImage_maker($truth);
        $whole_product = $whole_product . $image_chunk . ',';
      } else {
        // remove the 'field_' from the key to make our id
        $fix_key = ucfirst(str_replace('field_', '', $key));
        $chunk_name = 'prd' . $fix_key;
        $fix_value = str_replace('"','\"',$value);
        $html_chunk = tng_npHTML_maker($chunk_name, 'field-label', $key,  $fix_value);
        $whole_product = $whole_product . $html_chunk . ',';
      }

      dpm("**product**". $whole_product);

    }
    // after looping the HTML or Image group, remove the final ','
    $whole_product = rtrim($whole_product, ",");
    $finish_chunk = tng_npPageContentFeatureCleanup();
    $whole_product = $whole_product . $finish_chunk;
    dpm('**** product ****');
    dpm($whole_product);

    // when we edit a new node for a product (or make it for the first time), create a new object_manifest
    // to create an updated manifest, delete the old manifest and re-edit the product
    $new_nid = tng_create_manifest_node($whole_product, 'object_manifest', $manifest_title, $language, $nid);
    // return the new nid to set it on the parent node
    return $new_nid;
  } else {
    dpm('Received more or less items than we expected for our product, so we are not processing it.');
  }
}

/**
 * @param $object_values
 * @param $language
 * @param $nid
 * @return mixed
 */
function process_hotspot($object_values, $language, $nid) {
  dpm('**language**' . $language);
  dpm($object_values);
  //create an npFeature, npContent, npPage, and multiple npHTML chunks to make a NP product page
  // and if we find between 1 and 3 fields, layout the page
  $min_product_fields = 1;
  $max_product_fields = 3;
  $num_fields = count($object_values);
  if ($num_fields >= $min_product_fields && $num_fields <= $max_product_fields) {
    // here we process the fields we find for our hot spot passed in the array of $object_values
    //  start by telling the processor how many fields we found
    dpm('Hot Spot had ' . $num_fields . ' fields.');
    $title = $object_values['title_field'];
    dpm('title : ' . $title);
    $feature_chunk = tng_npFeature_maker($title, '["../../../assets/hts.css"]', '0.0.1');
    //language specific code here, we can only handle english, traditional and simplified chinese, if none of these default to english
    $language_strings = make_language_strings($language);
    $manifest_language = $language_strings[0];
    $manifest_content = $language_strings[1];
    $manifest_title = 'Hot Spot Manifest - ' . $title;
    $content_chunk = tng_npContent_maker($manifest_content, $manifest_language,  $manifest_title, 'This manifest creates a hot spot page.');
    // for some reason, 'Welcome' is a magic title that allows the rest of the HTML pages to work.
    $page_chunk = tng_npPage_maker('Welcome', '', $title,  'true');

    $whole_hotspot = $feature_chunk . $content_chunk . $page_chunk;
    foreach ($object_values as $key=>$value) {
      dpm('**** data ****' . $key . ' : ' . $value);

      if ($key == 'field_hot_spot_image') {
        $truth = tng_convert_drupal_to_mean_filename($value);
        $image_chunk = tng_npImage_maker($truth);
        $whole_hotspot = $whole_hotspot . $image_chunk . ',';
      } else {
        // remove the 'field_' from the key to make our id
        $fix_key = ucfirst(str_replace('field_', '', $key));
        $chunk_name = 'hts' . $fix_key;
        $fix_value = str_replace('"','\"',$value);
        $html_chunk = tng_npHTML_maker($chunk_name, 'field-label', $key,  $fix_value);
        $whole_hotspot = $whole_hotspot . $html_chunk . ',';
      }

      dpm("**hotspot**". $whole_hotspot);

    }
    // after looping the HTML or Image group, remove the final ','
    $whole_hotspot = rtrim($whole_hotspot, ",");
    $finish_chunk = tng_npPageContentFeatureCleanup();
    $whole_hotspot = $whole_hotspot . $finish_chunk;
    dpm('**** hotspot ****');
    dpm($whole_hotspot);

    // when we edit a new node for a hotspot (or make it for the first time), create a new object_manifest
    // to create an updated manifest, delete the old manifest and re-edit the product
    $new_nid = tng_create_manifest_node($whole_hotspot, 'object_manifest', $manifest_title, $language, $nid);
    // return the new nid to set it on the parent node
    return $new_nid;
  } else {
    dpm('Received more or less items than we expected for our hotspot, so we are not processing it.');
  }
}

function process_question_and_answer($object_values, $language, $nid) {
  dpm('**language**' . $language);
  dpm($object_values);
  //create an npFeature, npContent, npPage, and multiple npHTML chunks to make a NP product page
  // and if we find between 1 and 3 fields, layout the page
  $min_product_fields = 1;
  $max_product_fields = 10;
  $num_fields = count($object_values);
  if ($num_fields >= $min_product_fields && $num_fields <= $max_product_fields) {
    // here we process the fields we find for our question and answer passed in the array of $object_values
    //  start by telling the processor how many fields we found
    dpm('Question and Answer had ' . $num_fields . ' fields.');
    $title = $object_values['title_field'];
    dpm('title : ' . $title);
    $feature_chunk = tng_npFeature_maker($title, '["../../../assets/qaa.css"]', '0.0.1');
    //language specific code here, we can only handle english, traditional and simplified chinese, if none of these default to english
    $language_strings = make_language_strings($language);
    $manifest_language = $language_strings[0];
    $manifest_content = $language_strings[1];
    $manifest_title = 'Q and A Manifest - ' . $title;
    $content_chunk = tng_npContent_maker($manifest_content, $manifest_language,  $manifest_title, 'This manifest creates a question and answer page.');
    // for some reason, 'Welcome' is a magic title that allows the rest of the HTML pages to work.
    $page_chunk = tng_npPage_maker('Welcome', '', $title,  'true');

    $whole_qa = $feature_chunk . $content_chunk . $page_chunk;
    foreach ($object_values as $key=>$value) {
      dpm('**** data ****' . $key . ' : ' . $value);

      if ($key == 'field_answer_image') {
        $truth = tng_convert_drupal_to_mean_filename($value);
        $image_chunk = tng_npImage_maker($truth);
        $whole_qa = $whole_qa . $image_chunk . ',';
      } else {
        // remove the 'field_' from the key to make our id
        $fix_key = ucfirst(str_replace('field_', '', $key));
        $chunk_name = 'qaa' . $fix_key;
        $fix_value = str_replace('"','\"',$value);
        $html_chunk = tng_npHTML_maker($chunk_name, 'field-label', $key,  $fix_value);
        $whole_qa = $whole_qa . $html_chunk . ',';
      }

      dpm("**question answer**". $whole_qa);

    }
    // after looping the HTML or Image group, remove the final ','
    $whole_qa = rtrim($whole_qa, ",");
    $finish_chunk = tng_npPageContentFeatureCleanup();
    $whole_qa = $whole_qa . $finish_chunk;
    dpm('**** qa ****');
    dpm($whole_qa);

    // when we edit a new node for a questionanswer (or make it for the first time), create a new object_manifest
    // to create an updated manifest, delete the old manifest and re-edit the product
    $new_nid = tng_create_manifest_node($whole_qa, 'object_manifest', $manifest_title, $language, $nid);
    // return the new nid to set it on the parent node
    return $new_nid;
  } else {
    dpm('Received more or less items than we expected for our question and answer, so we are not processing it.');
  }

}


function process_content_object($object_values, $language) {
  dpm('**language**' . $language);
  dpm($object_values);
}


/**
 * @param $node_data - this is the full manifest to save on a separate node
 * @param $node_type - the type of node we are creating
 * @param $node_title - the title of the node
 * @param $node_language - not used currently due to bug
 * @param $nid - if this id is passed we won't make a new one, if not set create one
 * @return mixed - the nid is returned
 */
function tng_create_manifest_node ($node_data, $node_type, $node_title, $node_language, $nid) {

  global $user;

  // don't make a new manifest node if we already have one
  if (!isset($nid))
  {
    dpm('creating a new nid node manifest');
    $node = new stdClass();
    $node->title = $node_title;
    $node->type = $node_type;
    node_object_prepare($node); // Sets some defaults. Invokes hook_prepare() and hook_node_prepare().
    //language will not be set on the manifest but each manifest contains language specific goods
    //this feels like a bug, but we work around not being able to create manifest with languages by setting manifest language to 'und'
    //otherwise it will create a node with no body content, see the process_product function for more on language setting
    $node->language = LANGUAGE_NONE;
    //$node->language = $node_language; // unfortunately this doesn't work
    $node->uid = $user->uid;
    $node->status = 1; //(1 or 0): published or not
    $node->promote = 0; //(1 or 0): promoted to front page
    $node->comment = 0; // 0 = comments disabled, 1 = read only, 2 = read/write

    $node->body[$node->language][] = array(
      'value' => $node_data,
      'format' => 'plain_text',
    );

    $node = node_submit($node); // Prepare node for saving
    node_save($node);
    return $node->nid;
  }
}

/**
 * @param $value - full pathname of the local drupal image file
 * @return string - return the path which we will expect on the MEAN server side 'assets + stylepath'
 */
function tng_convert_drupal_to_mean_filename($value) {
  $justpath = parse_url($value, PHP_URL_PATH);
  dpm('***path value***'. $justpath);
  $needle = "/default/files/";
  $match = strpos($justpath, $needle);
  $match = $match + strlen($needle);
  dpm('***index***'. $match);
  $remote_picture_name = 'assets/' . substr($justpath, $match);
  return $remote_picture_name;
}

function tng_paragraph_processor() {

}
  /**
 * @param $entity - This view entity is passed
 * from the shadow module to construct a valid JSON object that the NewPlayerV2 can consume.
 * We process the paragraph portion since shadowed entities does not.
 *
 * We loop through the 'field_xyz' pieces which came from field_info_instances element_children.
 *
 *   for (each field we find)
 *     go through each element child and look for a paragraph type
 *       if (it is a paragraph)
 *         loop through it to find all pairs of questions and possible multiple answers
 *          note this information in the premanifest object
 *       else
 *         note the node and data in our premanifest object
 *   end
 */

function tng_shadow_shadow_request_alter($entity) {

  try {
    dpm ($entity);
    $entity_array = (array) $entity;
    dpm ($entity_array);
    $language = $entity->path['language'];
    //dpm($language);
    global $namevalue;
    $pre_manifest = array();

    // load the current entity in a wrapper
    $wrapper = entity_metadata_wrapper('node', $entity);
    //dpm(_wrapper_debug($wrapper));
    // given our node entity type, get all the fields for it
    $entity_type = $entity->type;
    // this hook is intended for creating content, not to process manifests since they are made when we create a product
    if ($entity_type == 'object_manifest') {
      dpm('Manifest found, quitting now!');
      return;
    }
    // field_info_instances holds the field values at the outermost level
    // paragraph types must be explored more, 'regular' value fields are written as is.
    $node_fields = field_info_instances('node', $entity_type);
    $number_of_fields = count($node_fields);
    dpm('found ' . $number_of_fields . ' ' . $entity_type . ' fields ');
    $children_nodes_to_process = element_children($node_fields);
    // we loop through the fields looking for a paragraph type to expand and rewrite
    for ($i=0; $i < $number_of_fields; $i++) {
      dpm('['. $i .']:' . $children_nodes_to_process[$i]);
      //dpm($children_nodes_to_process[$i]);
      //dpm($wrapper->$children_nodes_to_process[$i]->value());
      $info = field_info_field($children_nodes_to_process[$i]);
      if ($info['type'] == 'paragraphs') {
        // the outer node type is a 'field_paragraph_multiple_choice', so save this name for later pre-manifest creation.
        $save_field_name = $children_nodes_to_process[$i];
        $namevalue = '[ { ' ;
        // if we have a paragraphs type, use a wrapper for easier reference
        $paragraphs = $wrapper->$info['field_name']->value();
        dpm('paragraphs');
        dpm($paragraphs);
        $number_of_paragraphs = count($wrapper->$info['field_name']->value());
        dpm($number_of_paragraphs . ' ' . $info['field_name']  . ' paragraphs found.');
        // using the paragraphs bundle type, we can get all the fields we need to account for in our data
        $paragraph_fields = field_info_instances('paragraphs_item', $paragraphs->bundle);
        $number_of_paragraph_fields = count($paragraph_fields);
        //dpm($paragraph_fields);
        dpm($number_of_paragraph_fields . $paragraph_fields['field_name'] . ' paragraph fields found.');
        $children_fields_to_process = element_children($paragraph_fields);
        // explore each paragraph
        for ($p=0; $p < $number_of_paragraphs; $p++) {
          // and every field for each paragraph
          for ($pf=0; $pf < $number_of_paragraph_fields; $pf++) {
            // inside the fields within a paragraph the language variable is not used, it's 'und'
            $language = 'und';
            $field_name = $children_fields_to_process[$pf];
            //dpm('field_name : ' . $field_name);
            $field_child_info = field_info_field($children_fields_to_process[$pf]);
            //dpm('fi');
            //dpm($field_child_info);
            $name = $field_child_info['field_name'];
            //dpm('name : ' . $name);
            if (isset($paragraphs->{$name}[$language][0]['value'])) {
              $namevalue = $namevalue . '"' . $field_name . '" : "' . $paragraphs->{$name}[$language][0]['value']. '",';
            } else {
              $namevalue = $namevalue . '"' . $field_name . '" : ' . '"",';
            }
            //$field_info = $paragraphs->{$name}[$language][0]['value'];
            //dpm($field_info);
            //$num
            $field_count = count($paragraphs->{$name}[$language]);
            // if there are no elements in the field don't process
            if ($field_count < 1) {
              continue;
            } else {
              // typical question
              dpm($field_count .  ' field(s) sets found for ' . $paragraphs->{$name}[$language][0]['value']);
              if (($field_count == 1) && (isset($paragraphs->{$name}[$language][0]['value']))) {
                dpm('name : '. $name . ' value : ' . $paragraphs->{$name}[$language][0]['value']);
              } else {
                // typically answers
                for ($f=0; $f < $field_count; $f++) {
                  $entity = paragraphs_item_load($paragraphs->{$name}[$language][$f]['value']);
                  //dpm($entity);
                  $para_inst = field_info_instances('paragraphs_item', $entity->bundle());
                  //dpm($para_inst);
                  $sub_children = element_children($para_inst);
                  foreach ($sub_children as $key=>$value) {
                    //dpm($key);
                    // if the value for a field is set, we will output it (and skip blank fields)
                    if (isset($entity->{$value}[$language][0]['value'])) {
                      dpm($value);
                      dpm($entity->{$value}[$language][0]['value']);
                      $namevalue = $namevalue . '"' . $value . '":"' . $entity->{$value}[$language][0]['value'] . '",';
                    }
                    $info = field_info_field($sub_children[$key]);
                    //dpm($info);
                    // expect 'file' or 'image' here
                    $field_name = $value;
                    if ($info['type'] == 'image') {
                      $image_style = $node_fields[$field_name]['display']['default']['settings']['image_style'];
                      $fid = $entity_array[$field_name][$language][0]['fid'];
                      if ($fid) {
                        $file_id = file_load($fid);
                        $uri = $file_id->uri;
                        $image_style_path = image_style_url($image_style, $uri);
                      } else {
                        $image_style_path = '';
                      }
                      dpm($field_name . ': ' . $image_style_path);
                    }
                    if ($info['type'] == 'taxonomy_term_reference') {
                      $number_of_terms = count($entity_array[$field_name][$language]);
                      dpm($field_name);
                      for ($t=0; $t < $number_of_terms; $t++) {
                        $tids = array($entity_array[$field_name][$language][$t]['tid']);
                        $terms = taxonomy_term_load_multiple($tids);
                        foreach ($terms as $term) {
                          $name = $term->name;
                          dpm($name);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        // remove the final ',' and add the final '} ]' to be syntax correct on the json
        $namevalue = trim($namevalue, ",") . '} ]';
        $manifest[]  = $namevalue;
        $pre_manifest[$save_field_name] = $namevalue;
        dpm($namevalue);
      }
      elseif ($info['type'] == 'entityreference') {
        // todo: think of a better way to process for entity references than to check the type for product
        if ($entity_type == 'product_detail') {
          dpm('found an entity reference node to fetch and process');
          dpm($entity_type);
          $objects  = $wrapper->$info['field_name']->value();
          dpm('paragraphs');
          dpm($objects);
          $num_entity_refs = count($wrapper->$info['field_name']->value());
          $field_name = $info['field_name'];
          dpm('found ' .  $num_entity_refs . ' entity references.');
          for ($num=0; $num < $num_entity_refs; $num++) {
            $targetid = $entity_array[$field_name][$language][$num]['target_id'];
            dpm($targetid);
            $csv = '';
            $partnerinfo = tng_title_and_image_extractor($targetid);
            dpm('post fetch');
            dpm($partnerinfo);
            foreach ($partnerinfo as $key ) {
              dpm($key);
              $csv = $csv . $key . ',';
            }
            dpm($csv);
            $pre_manifest[$field_name] = $csv;
          }
        }
//          elseif ($entity_type == 'content_object') {
//          //todo: new logic needed to handle embedded content object pieces (just load from manifest?)
//          dpm('found a content object entity reference, now loading manifests');
//
//        }
      }
      elseif ($info['type'] == 'image') {
        dpm('found an image');
        $field_name = $info['field_name'];
        $image_style = $node_fields[$field_name]['display']['default']['settings']['image_style'];
        $fid = $entity_array[$field_name][$language][0]['fid'];
        if ($fid) {
          $file_id = file_load($fid);
          $uri = $file_id->uri;
          $image_style_path = image_style_url($image_style, $uri);
        } else {
          $image_style_path = '';
        }
        dpm($field_name . ': ' . $image_style_path);
        $pre_manifest[$field_name] = $image_style_path;
        dpm($pre_manifest);
      }
      elseif ($info['type'] == 'text' || $info['type'] == 'text_long') {
        dpm('found text or text_long field');
        $pre_manifest[$children_nodes_to_process[$i]] = $wrapper->$children_nodes_to_process[$i]->value();
        dpm($pre_manifest);
      }
      elseif ($info['type'] == 'file') {
        dpm('found an outer node file');
        $field_name = $info['field_name'];
        $fid = $entity_array[$field_name][$language][0]['fid'];
        $file_id = file_load($fid);
        $uri = $file_id->uri;
        $thefilepath = file_create_url($uri);
        dpm($field_name . ': ' . $thefilepath);
        $pre_manifest[$field_name] = $thefilepath;
      }
      elseif ($info['type'] == 'taxonomy_term_reference') {
        dpm('found a taxonomy term reference');
        $field_name = $info['field_name'];
        $number_of_terms = count($entity_array[$field_name][$language]);
        dpm('number of terms : '. $number_of_terms);
        dpm($field_name);
        $collector = '';
        for ($t=0; $t < $number_of_terms; $t++) {
          $tids = array($entity_array[$field_name][$language][$t]['tid']);
          $terms = taxonomy_term_load_multiple($tids);
          foreach ($terms as $term) {
            $name = $term->name;
            dpm($name);
            $collector = $collector . $name . ',';
          }
        }
        $pre_manifest[$field_name] = $collector;
      }
      elseif (($info['type']== 'list_text') || ($info['type']== 'list_boolean')) {
        dpm('found some list_text or list_boolean');
        $field_name = $info['field_name'];
        $pre_manifest[$field_name] = $wrapper->$children_nodes_to_process[$i]->value();
        dpm($pre_manifest);
      }
      elseif ($info['type'] == 'object_manifest') {
        dpm('found me a manifest to play with');
        $field_name = $info['field_name'];
        $pre_manifest[$field_name] = $entity_array[$children_nodes_to_process[$i]]['und'][0]['value'];
      }
      else {
        // this section needs work, since it must handle any types we don't know about.
        dpm('not anything we have seen before, saving value on object : '. $info['type']);
        dpm($info);
        // if we have a title, it is language specific, if not use $language
//        if ($children_nodes_to_process[$i] == 'title_field') {
//          dpm($entity_array[$children_nodes_to_process[$i]][$entity_array['language']][0]['value']);
//          //dpm($namevalue);
//          $namevalue = $namevalue . $entity_array[$children_nodes_to_process[$i]][$entity_array['language']][0]['value'];
//          dpm($namevalue);
//          $manifest[]  = $namevalue;
//        } else {
//          //dpm($entity_array[$children_nodes_to_process[$i]][$language][0]['value']);
//          //dpm($namevalue);
//          $namevalue  = $namevalue . $entity_array[$children_nodes_to_process[$i]][$language][0]['value'];
//          dpm($namevalue);
//          $manifest[] = $namevalue;
//        }
      }
    }

    // whatever type of entity we discover while processing, handle each by the type it is

    // uncomment the following line to call the product tester
   //tng_test_product_creation();

    // if we have a product, convert it to a manifest
    if ($entity_type == 'product_detail') {
      dpm('found a product to work on with language ' . $language);
      dpm('pre manifest, then nid to pass');
      dpm($pre_manifest);
      dpm($entity_array['field_manifest'][$language][0]['target_id']);
      // the manifest field is where we store the nid value for the json manifest for NewPlayerV2.
      $new_nid = process_product($pre_manifest, $language, $entity_array['field_manifest'][$language][0]['target_id']);
      // if we find a new nid, attach it to the parent node, otherwise don't do anything with it.
      if (isset($new_nid)) {
        dpm('setting new manifest nid on entity');
        $entity->field_manifest[$language][0]['target_id'] = $new_nid;
        node_save($entity);
      }
    } elseif ($entity_type == 'content_object') {
      dpm('found a content object to work on');
      process_content_object($pre_manifest, $language);
    } elseif ($entity_type == 'hot_spots') {
      dpm('found a hot spot to work on');
      $new_nid = process_hotspot($pre_manifest, $language, $entity_array['field_manifest'][$language][0]['target_id']);
      if (isset($new_nid)) {
        dpm('setting new manifest nid on hot spot entity');
        $entity->field_manifest[$language][0]['target_id'] = $new_nid;
        node_save($entity);
      }
    } elseif ($entity_type == 'question_and_answer') {
      dpm('found a question_and_answer to work on');
      dpm($entity_array);
      dpm($entity_array['field_manifest']['en'][0]['target_id']);
      $new_nid = process_question_and_answer($pre_manifest, $language, $entity_array['field_manifest']['en'][0]['target_id']);
      if (isset($new_nid)) {
        dpm('setting new manifest nid on question_and_answer entity');
        $entity->field_manifest[$language][0]['target_id'] = $new_nid;
       node_save($entity);
      }
    }
  }
  catch (exception $e) {
    dpm($e);
  }

}

function tng_entity_walker ($targetid) {
  try {
    $title = 'title_field';
    $image = 'field_product_image';
    $results = array();
    $entity = node_load($targetid);
    dpm('**entity**');
    dpm($entity);
//    $language = $entity->language;

//    $product_title = $entity->title_field[$language][0]['value'];
//    dpm($product_title);
//    $results[$title] = $product_title;
//    $thumb = $entity->field_product_image[$language][0]['uri'];
//    dpm('***thumb***'. $thumb);
//    $results[$image] = $thumb;
    return $entity;
  }
  catch (exception $e) {
    dpm($e);
  }
}


function array_to_obj($array, &$obj)
{
  foreach ($array as $key => $value)
  {
    if (is_array($value))
    {
      $obj->$key = new stdClass();
      array_to_obj($value, $obj->$key);
    }
    else
    {
      $obj->$key = $value;
    }
  }
  return $obj;
}

function arrayToObject($array)
{
  $object= new stdClass();
  return array_to_obj($array,$object);
}

function _wrapper_debug($w) {
  $values = array();
  foreach ($w->getPropertyInfo() as $key => $val) {
    $values[$key] = $w->$key->value();
  }
  return $values;
}

/**
 * call this function to test the syntax creation of the maker routines.
 * check the output at this website: http://jsonformatter.curiousconcept.com/
 * jsonlint.com eats html chunks for some reason and can't be used to check with.
 */

function tng_test_product_creation() {
  $feature_chunk = tng_npFeature_maker('Sample Product Display', '["../../../assets/anr.css"]', '0.0.5', '2014-Dec-Mon_04:12:22');
  //dpm($feature_chunk);
  $content_chunk = tng_npContent_maker('content_en-US', 'en-US', 'Sample Manifest', 'Sample presentation');
  //dpm($content_chunk);
  $page_chunk = tng_npPage_maker('Welcome', '', 'Advanced Night Repair',  'false');
  //dpm($page_chunk);
  $html_chunk = tng_npHTML_maker('anrBenefits', 'field-label', 'Benefits',  '<ol><li>Instantly&mdash;lines and wrinkles look plumped and smoothed.</li><li>In just one week&mdash;skin doubles its own natural collagen production.*</li><li>In just 4 weeks&mdash;96% of women showed a significant reduction in the look of lines & wrinkles.**</ol>');
  //dpm($html_chunk);
  $more_html_chunk = tng_npHTML_maker('anrDemonstration', 'field-label', 'Demonstration',  '<p>Apply 1 dropper to the back of one hand and massage into skin.<\/p><p>Lightly spray the backs of both hands with water, then compare hands. Tell your customer to pretend the water is a moisturizer.<\/p><p>Ask her to notice how the skin treated with Advanced Night Repair holds moisture, while the untreated skin experiences moisture loss (the water quickly rolls off).<\/p>');
  //dpm($more_html_chunk);
  $finish = tng_npPageContentFeatureCleanup();
  $combo =  $feature_chunk . $content_chunk . $page_chunk .  $html_chunk . ','.  $more_html_chunk  . $finish;
  dpm($combo);
}
